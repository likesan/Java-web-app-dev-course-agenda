성실함
	추후 인사담당자께 나의 모든 출석 정보가 옮겨간다고 한다.
	파이널 프로젝트로 
파일 리스트를 보여주는 서버 만들기
	File 리스트로 보여주는 명령어 
		File f= new File("D:\\2월자바SW개발자과정\\")
			그 해당 디렉토리의 주소를 설정하기 
			그 파일제어권을 얻은 뒤 inputstream으로 끌어올리기? 그리고 그걸 배열에 담기
			배열에 담은 것을 readfully로 읽어들이기
			리스트형으로 나타나게 하는방법은 내 모르니 문제? For each달아야하나? 자유자재로 for each도 써야하는데 
			For each ( collection 의 자료형-변수명 : collection ) { sysout(변수명)   } 변수명이 collection의 배열 크기만큼 던지면서 sysout발생됨

모호점
	for each 문을 정확히 어떻게 쓰는지 파악하지 못한듯,그 앞부분에 뭐가 나와야하는거지?
	FileOutputStream 이 DataOutputStream과 어떤 차이지? 한번 읽어보자 설명문을
		Fileoutputstream은 낡은거라고 한다. 대신에 dataoutputstream은 더 좋은 빨대라고 한다.
finally 
	unchecked exception : 발생할 수도 있고 아닐 수도 있는 에러의 상황
	에러가 생겼건 안생겼던 그냥 무조건 한번 해당 finally가 거쳐가며, 작동 되게 만들어버리는 명령어
	 무려 return;이 있더라도 해당 라인을 한번 거쳐서 실행되게 만드는 무시무시한 녀석
	언제든 실행되는 놈이다 try{ 구문 이후 } catch(){}
	return; 해당 메서드를 끝내버리는 종료, ![Pasted image](https://dynalist.io/u/8jNe4rGGvKALbfgx-oEJjVN4) 
	얘를 언제 쓰나?
		close를 안쓰면 큰 문제가 생길 수 있다?
		.close()를 써야하는데 unchecked exception이 발생할지도 모르는 경우 해당녀석을 try로 잡는다. 그 후에 finally 부분에서 .close()를 해주면 해당 메소드가 끝나기 전에 항상 .close()를 하므로 좋다.
		관례로서 많이 사용된다고한다 
		다만 dis!=null 같은 표현은 왜 들어가는가?
			초기 Socket, DataoutputStream, Datainputstream 등은 초기에 null값으로 지정되어 있다. 마치 정수에서 0값처럼 , 아무것도 지정되있지 않은 상태를 null '아무것도 없는 텅빈 존재'로 표현한다. 그런데 이것이 null이 아니라면, 다시말해 뭔가 stream등에 뭔가를 담고 있다면, close(); 하자며 마무리 하는 기능이다. 
				아 다시말해 뭔가가 있다고 되어있는 경우에는 클로즈로 닫아버려서, 뭔가 없는 경우인 경우에는 그냥 쓰지 않도록, 놔두도록, 다시말해 본래 아무것도 작동하지 않아 아무런 값이나 데이터를 stream에 담고 있지 않은 경우, 그냥 놔둔다. 왜냐면 이런 녀석들, 아무것도 담고 있지 않는 녀석들은 굳이 닫아줄 필요도 없으므로, 왜냐하면 아무것도 담고 있지 않다는 말은 아예 써진적이 없었다는 것을 반증하므로.
	try with resource? finally의 업그레이드 판
		checked exception?
		용법
			try  () 안에 넣어서 쓰기?
		최근 이클립스 1.7에 들어와서 생겨난 기능이라고 한다. 아직 생소한 탓에 쓰는 개발자가 많은 편은 아니지만, 나중에 dis!=null , dos!=null, soc!=null 등 일일히 지정해주고 try / catch 값을 막 넣어줘야하는 것이 굉장히 불편해서 나타난 대안적으로 해결책처럼 등장한 기능이다. 
			Try with resource 가 편안한 기능이다. 하지만 용법 파악이 제대로 안됐다. 다만 try 옆에 괄호를 열어 사용할 수 있다는 점에서 그 모습이 파악될 수 있다.
			우리가 능숙하게 사용하지 못하더라도 이렇게 눈에 익혀두려는 이유는, 적어도 나중에 당황하지 않기위함.
		all implemented class 중, autoclosable 인터페이스를 상속 받는 애만 사용 가능하다?
Thread
	for문과 동시에 gui가 출력되도록 하는 경우...?
	cli : command line interface
		dos
	gui : graphic user interface
		eclipse
		창을 옮기는 것
			frame으로 만들엇다가 지웠다가한다. cpu가 허벌 빠르다는 것
			기존 위치의 프레임은 지워지고, 동시에 커서로 드래그하는 위치로는 새로운 창들이 지속적으로 생기도록 하는 것, 다시말해 2개 이상의 기능이 동시에 구현되도록 만드는 기능이 바로 Threads 기능이다.
				이를 위해서는 첫째, 원하는 기능을 위한  class를 하나 선언한다. 그후 해당 클래스에 extends Thread 를 달아 thread 클래스를 상속받게 한다.
				그 후** run ()이라는 메소드를 내부에 선언**한 뒤, 그 안에 내가 추가하고자 하는 기능 을 넣는다.
				그 뒤 해당하는 기능이 실행되길 바라는 곳에서, (예를 들면 main class 내부) 해당 기능을 인스턴스화 시킨다. 예를 들어 해당 thread의 클래스 명이 A라고 한다면, A a = new A ();  그 다음 해당 인스턴스를  호출하며 해당 기능을 사용한다. 이때, 클래스명을 호출한 뒤, 점을 찍고 **start ()**라는 메소드를 사용하여야 한다.
					어떤 기능을 사용하고자 할때는 반드시 인스턴스화를 시켜주어야한다.
					왜냐하면 인스턴스로 만들 때 비로소 Ram 안에 실체적으로 데이터가 만들어지기 때문. 데이터를 만들어야 다음 작업들을 실행할 수 있기 때문이다. 이런 과정이 없다면 class에 작성된 추상적인 설계만을 갖고 있을 뿐 Ram안에 실제적인 내용들을 만들어낼 수가 없기 때문이다.
					
				그 뒤 ctrl + F11 (실행 shortcut) 을 사용하여 해당 기능이 작동하는지 테스트한다.
				위 같은 방법을 통해 실시간 채팅 프로그램을 만들 수도 있다. 물론 gui는 구현되지 않아 JOpane.input창만 띄운다면 그나마 좀 괜찮은 녀석이 되기도
	Thread, 그 이론
		파일 하나의 DISK 내용이 램으로 복사되는 것
			이렇게 들어온 DiSK의 내용은 Process라고 부른다.
			이 process는 여러개가 만들어진다.
			CPU는 스케쥴링을 통해 이 process 들 중에 하나를 해결하기 위해 노력한다. 각각의 process들에게 시간 배정을 해준다. (얘네들은 기계어로 된 명령어들). 그 배정들 안에 cPu가 처리 해주다 할당된 시간(예0.00003초) 이 지나가면 다음 프로세스로 가는 것.
			이 방법을 **시분할처리**라고 한다.
				이 안에 스케쥴링알고리즘을 사용하는건가? 기능자체를 우리는 시분할처리라고 하는건가?
			디스크>램>cpu로 읽어들이는 과정을 우리는 loading이라고 한다.
				cpu는 이미 어마어마하게 빠르다고 32억비트를 처리하는 정도라고
				뭔가 느리다고 여겨지는 건 DISK에서 RAM > CPU로 읽혀지는 과정, 다시말해 thread가 일감들을 들고 오는 속도 자체가 느리기때문, 하지만 cpu자체는 이미 미래의 기술이라 불릴 정도로 빠르다고
					SDD로 바꿔주면 해결되는 현상. = Loading 속도를 향상시킨다. = cpu에게 빨리 
			Thread 가 바로 일처리를 해결하는 단위
				process마다 하나씩 있어야한다고?
				하나의 process당 책임자로서, cpu에게 시간을 할당받는 책임자를 thread라고 한다. 
					하나의 process당 최소 하나의 thread가 붙어있어야한다고
					이클립스에서 한라인 한 라인들을 thread라고 부른다. 
					process, HDD로부터 불러들여온 일감들, 그리고 그 일감들을 해결하기위해 배정된 녀석들이 thread다.
					이 책임자들, thread를 여러개를 만들어서 cpu로부터 처리를 위한 시간들을 할당 받을 수 있는데, 이것들이 많아지면 multi threads라고 한다.
					우리가 multi-threads를 여러개 만든다는 것은 한 파일 안에 처리할 수 있는 여러개의 책임자를 만드는 것이라고?
예외 처리 vs 예외 전가?
	throws? 는 처리
	
super() 상위클래스를 호출하는 기능?
	상위클래스의 생성자를 부르는 기능
	왜 부르지?
		상속 받았을 경우에 쓰이는 것으로 보임. 다시말해 그 매개변수의 내용들이 해당 자식 클래스에도 적용되게 하기 위함. 아 그래서 모든 클래스는 자동적으로 수퍼클래스를 갖고 있는 듯. 물론 결국 object형을 상속 받겠지만?
Thread 사용법
	상속하자? 무얼? Thread 클래스를 하나 하자?
	thread는 파일 하나를 그냥 처리해내는 책임자로 보면되는 것 같다.
	그리고 이 thread들은 복잡한 프로세스들을 cpu가 알아서 처리해내도록 만들어낸 기능
	익숙해져야한다고... 그러면 5가지 스텝들과, 이걸 왜 써야하는지 정확히 파악해야하는게 아닐까? cpu... 그냥 하나의 프로세스를 해결하고자하거나 더 효과적으로 쓰고자 할때 써야하는걸까? 언제 써야하는거지? 음... 음... 음...
	plusThread? ![Pasted image](https://dynalist.io/u/pt9rGE57Fj5T_thAy_gG6v9o) 
		익명 인스턴스
		1회용만 가능하다?
		얘가 갑자기 왜 나온거지? 음... 새로운 인스턴스를 형성해서 하는 방법인가보다? 아 저렇게 해서 start를 호출해야하는구나
카운트다운 만들기
	 ![Pasted image](https://dynalist.io/u/HLZTPkjhovkrlGLO33Lkei_5) 
	thread.sleep(millis); 는 1000분의 1초 동안 **멈추게 하는 기능**
오늘 해야할게 많군
	trywithsource도 확인해야하고
	makingserver도 확인해봐야하네
	블로깅에 업로드도 해야하고 젠장 너무 좋네
		공부할 거리가 너무 많으니 정말 좋군!!

thread가 뭔가 그렇게 어렵지는 않구나.
	그냥 일단 extends로 상속한번 해주고, Thread라는 class를 말이지, 그리고 
	그놈을 class로 메인 class 바깥에 한번 만들어주고서는
	해당하는 기능을 run()이라는 메소드 안에 넣어서 
컬러로 잡히면 스페이스를 눌러 깬다
	 ![Pasted image](https://dynalist.io/u/Am8KwUymGADxPHppLqM4sFFr) 
채팅방 만들기
	설계
		input-output을 만든다, main 에는 Client로 한다면 socket을, 서버라면 다른놈을 만들어주도록 하자(뭘 만들어야하지?)
			서버라면 ServerSocket 을 하나 만든다? 그 serverSocket에는 포트번호를 입력한다?
			그리고 그 sock = server.accept로 만든다
				server.accept의 기능은 뭔가를 받아내는 기능이다?
				아.. 서버가 갖는 기능, 근데 왜 server를 호출해서 .accept를 하는거지? 
					accept라는 기능은 socket을 서버로부터 하나 내보내는 기능. 다시말해, 상대가 접속한 경우, return 값으로 새로운 socket을 하나 내보내준다.
	프로젝트 회의 
		그림 파일을 보내고, 관련된 내용에 대해 코멘트를 받을 수 있는 프로그램?
		뭔가 이런저런 아이디어 구성을 위해 고민했다. 똥피하기라던가 어떤 강의 관리 프로그램 (질문 던지기, 강사님께 메시지보내기, 화장실 가고싶음 알림 메시지 띄우기, 질문 그림에 코멘트 달기) - 왜? 질문이 불편해서? 익명으로 보낼 수 잇는 그런 학습 도우미 프로그램
			매우 좋은 것 같은데?
			내가 해야될게 뭐가 있을까? 
				준비? 
				음.. 라이브러리 찾기?
				그래픽 구현?
		화면을 볼 수 있도록 띄우는 프로그램?
